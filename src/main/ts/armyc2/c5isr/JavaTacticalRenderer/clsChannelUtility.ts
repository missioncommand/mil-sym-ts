import { type int, type double } from "../graphics2d/BasicTypes";

import { BasicStroke } from "../graphics2d/BasicStroke"
import { Rectangle2D } from "../graphics2d/Rectangle2D"
import { arraysupport } from "../JavaLineArray/arraysupport"
import { CELineArray } from "../JavaLineArray/CELineArray"
import { Channels } from "../JavaLineArray/Channels"
import { lineutility } from "../JavaLineArray/lineutility"
import { POINT2 } from "../JavaLineArray/POINT2"
import { ref } from "../JavaLineArray/ref"
import { Shape2 } from "../JavaLineArray/Shape2"
import { TacticalLines } from "../JavaLineArray/TacticalLines"
import { P1 } from "../JavaTacticalRenderer/P1"
import { TGLight } from "../JavaTacticalRenderer/TGLight"
import { Color } from "../renderer/utilities/Color"
import { EntityCode } from "../renderer/utilities/EntityCode"
import { ErrorLogger } from "../renderer/utilities/ErrorLogger"
import { IPointConversion } from "../renderer/utilities/IPointConversion"
import { RendererException } from "../renderer/utilities/RendererException"
import { SymbolID } from "../renderer/utilities/SymbolID"
import { clsRenderer2 } from "../RenderMultipoints/clsRenderer2"
import { clsUtility } from "./clsUtility";

/**
 * A class to process channel types.
 *
 *
 */
export class clsChannelUtility {

    private static readonly _className: string = "clsChannelUtility";

    /**
     * Gets partitions from the client points based on the segments generated by
     * GetSegments. Partitions are used handle double-backed segments. Each
     * partition is a continuous sequence of points for a channel.
     *
     * @param segments
     * @param partitions OUT the partitions
     * @return
     */
    private static GetPartitions(segments: boolean[],
        partitions: Array<P1>): int {
        try {
            let j: int = 0;
            let nextSegment: boolean = false;
            //worst case is every segment is a separate partition
            //caller must deallocate partitions
            let p1: P1 = new P1();
            //first segment will always be true,
            //there are no bad one-segment channels
            if (segments[0] === false) {
                return 0;
            }

            if (partitions != null) {
                partitions.length = 0; // partitions.clear()
            } else {
                return 0;
            }

            p1.start = 0;
            //only add the partitions after p1.end has been set
            let n: int = segments.length;
            //for (j = 0; j < segments.length - 1; j++) 
            for (j = 0; j < n - 1; j++) {
                nextSegment = segments[j + 1];
                if (nextSegment === false) {
                    //the end of the current partition is the last good segment
                    p1.end_Renamed = j;
                    partitions.push(p1);
                    //beginning of the next partition
                    p1 = new P1();
                    p1.start = j + 1;
                }
            }
            p1.end_Renamed = j;
            partitions.push(p1);
        } catch (exc) {
            if (exc instanceof Error) {
                //console.log(e.message);
                //clsUtility.WriteFile("error in clsChanneUtility.GetPartitions");
                ErrorLogger.LogException(clsChannelUtility._className, "GetPartitions",
                    new RendererException("Failed inside GetPartitions", exc));
            } else {
                throw exc;
            }
        }
        return partitions.length;
    }

    /**
     * Draws a partition to the shapes array and stores the calculated channel
     * points
     *
     * @param fromSegment
     * @param toSegment
     * @param pixels
     * @param channelWidth
     * @param bolLastSegment
     * @param shapes
     * @param channelPoints
     * @param distanceToChannelPoint
     * @return
     */
    private static DrawGoodChannel2(tg: TGLight,
        fromSegment: int,
        toSegment: int,
        pixels: number[],
        channelWidth: int,
        bolLastSegment: boolean,
        shapes: Array<Shape2>,
        channelPoints: Array<POINT2>,
        distanceToChannelPoint: double): int {
        let returnValue: int = 0;	// Had to initialize to something
        try {
            let lineType: int = tg.get_LineType();
            let lineType2: int = 0;
            let channelPixels: number[];
            switch (lineType) {
                case TacticalLines.LC:
                case TacticalLines.LC_HOSTILE:
                case TacticalLines.UNSP:
                case TacticalLines.DFENCE:
                case TacticalLines.SFENCE:
                case TacticalLines.DOUBLEA:
                case TacticalLines.LWFENCE:
                case TacticalLines.HWFENCE:
                case TacticalLines.SINGLEC:
                case TacticalLines.DOUBLEC:
                case TacticalLines.TRIPLE: {
                    lineType2 = lineType;
                    break;
                }

                case TacticalLines.SPT: {
                    if (fromSegment === 0) {
                        lineType2 = TacticalLines.CHANNEL_FLARED;
                    } else {
                        lineType2 = TacticalLines.CHANNEL;
                    }
                    break;
                }

                case TacticalLines.MAIN: {
                    if (fromSegment === 0) {
                        lineType2 = TacticalLines.CHANNEL_FLARED;
                    } else {
                        lineType2 = TacticalLines.CHANNEL;
                    }
                    break;
                }

                case TacticalLines.CATK: {
                    lineType2 = TacticalLines.CHANNEL_DASHED;
                    break;
                }

                case TacticalLines.CATKBYFIRE: {
                    lineType2 = TacticalLines.CHANNEL_DASHED;
                    break;
                }

                default: {
                    lineType2 = TacticalLines.CHANNEL;
                    break;
                }

            }
            if (bolLastSegment === true) {
                if (fromSegment !== 0) {
                    switch (lineType) {
                        case TacticalLines.SPT: {
                            lineType2 = TacticalLines.SPT_STRAIGHT;
                            break;
                        }

                        case TacticalLines.MAIN: {
                            lineType2 = TacticalLines.MAIN_STRAIGHT;
                            break;
                        }

                        default: {
                            lineType2 = lineType as int;
                            break;
                        }

                    }
                } else {
                    lineType2 = lineType as int;
                }
            }

            if (fromSegment < 0) {
                return returnValue;
            }
            if (toSegment < 0) {
                return returnValue;
            }
            if (toSegment < fromSegment) {
                return returnValue;
            }
            let j: int = 0;
            let lineCount: int = 0;
            let numPoints: int = 0;
            let counter: int = 0;
            let goodUpperPixels: number[];
            let goodLowerPixels: number[];
            numPoints = toSegment - fromSegment + 2;
            goodUpperPixels = new Array<number>(2 * numPoints);
            goodLowerPixels = new Array<number>(2 * numPoints);

            counter = 0;
            for (j = fromSegment; j < toSegment + 2; j++) {
                goodUpperPixels[counter] = pixels[2 * j];
                goodUpperPixels[counter + 1] = pixels[2 * j + 1];
                goodLowerPixels[counter] = pixels[2 * j];
                goodLowerPixels[counter + 1] = pixels[2 * j + 1];
                counter = counter + 2;
            }

            tg.set_LineType(lineType2);
            lineCount = CELineArray.CGetLineCountDouble(tg, goodUpperPixels, numPoints, channelWidth);
            channelPixels = new Array<number>(3 * lineCount);
            let pt: POINT2;
            lineCount = Channels.GetChannel1Double(tg, goodUpperPixels, goodLowerPixels, channelPixels, numPoints, numPoints, channelWidth / 2, distanceToChannelPoint as int, shapes);
            tg.set_LineType(lineType);

            //if shapes is null then it is not a CPOF client
            if (shapes == null && channelPixels != null) {
                //do not clear channelPoints first because the function gets successive calls
                let n: int = channelPixels.length;
                //for (j = 0; j < channelPixels.length / 3; j++) 
                for (j = 0; j < n / 3; j++) {
                    pt = new POINT2(channelPixels[3 * j], channelPixels[3 * j + 1], channelPixels[3 * j + 2] as int);
                    if (j === channelPixels.length / 3 - 1) {
                        pt.style = 5;
                    }
                    channelPoints.push(pt);
                }
            }

            if (lineCount > 0) {
                //DrawChannelPixels2(lineCount, channelPixels, (int)lineType);
                returnValue = channelPixels.length;
            } else {
                returnValue = 0;
            }
            //channelPixels[channelPixels.length - 1] = 5;
            if (lineCount > 0) {
                channelPixels[lineCount - 1] = 5;
            }
            //clean up
            goodUpperPixels = null;
            goodLowerPixels = null;
        } catch (exc) {
            if (exc instanceof Error) {
                //clsUtility.WriteFile("error in clsChanneUtility.DrawGoodChannel2");
                ErrorLogger.LogException(clsChannelUtility._className, "DrawGoodChannel2",
                    new RendererException("Failed inside DrawGoodChannel2", exc));
            } else {
                throw exc;
            }
        }
        return returnValue;
    }

    /**
     * Draws the channel partitions to the shapes array
     *
     * @param pixels
     * @param partitions
     * @param channelWidth channel width in pixels
     * @param shapes
     * @param channelPoints
     * @param distanceToChannelPoint distance in pixels from the tip to the back
     * of the arrow
     */
    private static DrawSegments(tg: TGLight,
        pixels: number[],
        partitions: Array<P1>,
        channelWidth: int,
        shapes: Array<Shape2>,
        channelPoints: Array<POINT2>,
        distanceToChannelPoint: double): void {
        try {
            let j: int = 0;
            let n: int = 0;
            let t: int = partitions.length;
            //for (j = 0; j < partitions.length - 1; j++) 
            for (j = 0; j < t - 1; j++) {
                n = clsChannelUtility.DrawGoodChannel2(tg, partitions[j].start, partitions[j].end_Renamed, pixels, channelWidth, false, shapes, channelPoints, distanceToChannelPoint);

            }
            //draw the last partition using linetype
            n = clsChannelUtility.DrawGoodChannel2(tg, partitions[j].start, partitions[j].end_Renamed, pixels, channelWidth, true, shapes, channelPoints, distanceToChannelPoint);
        } catch (exc) {
            if (exc instanceof Error) {
                //clsUtility.WriteFile("error in clsChanneUtility.DrawSegments");
                ErrorLogger.LogException(clsChannelUtility._className, "DrawSegments",
                    new RendererException("Failed inside DrawSegments", exc));
            } else {
                throw exc;
            }
        }
    }

    private static DrawLCSingleLineSegments(tg: TGLight,
        pixels2: number[],
        singleLinePartitions: Array<P1>,
        shapes: Array<Shape2>,
        clipBounds: Rectangle2D,
        converter: IPointConversion): void {
        try {
            for (let flotPartition of singleLinePartitions) {
                let vblSaveCounter: int = flotPartition.end_Renamed - flotPartition.start + 1;
                let flotPixels: Array<POINT2> = new Array();
                for (let i: int = 0; i < vblSaveCounter; i++) {

                    flotPixels.push(new POINT2(pixels2[2 * (i + flotPartition.start)], pixels2[2 * (i + flotPartition.start) + 1]));
                }


                let flotID: string = tg.get_SymbolId();
                flotID = SymbolID.setAffiliation(flotID, SymbolID.StandardIdentity_Affiliation_Hostile_Faker);
                flotID = SymbolID.setEntityCode(flotID, EntityCode.EntityCode_FLOT);
                let flotTG: TGLight = new TGLight();
                flotTG.set_LineType(TacticalLines.FLOT);
                flotTG.set_Pixels(flotPixels);
                flotTG.set_SymbolId(flotID);
                flotTG.set_LineThickness(tg.get_LineThickness());

                let flotShapes: Array<Shape2> | null = clsRenderer2.GetLineArray(flotTG, converter, false, clipBounds);

                if (flotShapes != null) {
                    for (let shape of flotShapes) {

                        shape.setLineColor(Color.RED);
                    }

                    shapes.push(...flotShapes);
                }
            }
        } catch (exc) {
            if (exc instanceof Error) {
                ErrorLogger.LogException(clsChannelUtility._className, "DrawLCFlotSegments",
                    new RendererException("Failed inside DrawLCFlotSegments", exc));
            } else {
                throw exc;
            }
        }
    }

    /**
     * Handle symbol too small for line of contact
     * @param tg
     * @param pixels
     * @return 
     */
    private static getLCPixels(tg: TGLight, pixels: Array<POINT2>): Array<POINT2> {
        let pixels2: Array<POINT2>;
        try {
            if (tg.get_LineType() !== TacticalLines.LC) {

                return pixels;
            }

            let pts: POINT2[] = tg.Pixels;
            let ul: POINT2 = new POINT2();
            let lr: POINT2 = new POINT2();
            lineutility.CalcMBRPoints(pts as POINT2[], pts.length, ul, lr);
            let flotDiameter: double = arraysupport.getScaledSize(21, tg.get_LineThickness());
            if (lr.x - ul.x >= flotDiameter) {

                return pixels;
            }

            else {
                if (lr.y - ul.y >= flotDiameter) {

                    return pixels;
                }

            }

            //at this point the mbr is too small for a meaningful LC symbol
            let x0: double = pts[0].x;
            let y0: double = pts[0].y;
            let x1: double = pts[1].x;
            let y1: double = pts[1].y;
            if (x0 <= x1) {

                x1 = x0 + flotDiameter;
            }

            else {

                x1 = x0 - flotDiameter;
            }

            y1 = y0;
            let pt0: POINT2 = new POINT2(x0, y0);
            let pt1: POINT2 = new POINT2(x1, y1);
            pixels2 = new Array();
            pixels2.push(pt0);
            pixels2.push(pt1);
        } catch (exc) {
            if (exc instanceof Error) {
                //clsUtility.WriteFile("error in clsChanneUtility.DrawSegments");
                ErrorLogger.LogException(clsChannelUtility._className, "getLCPixels",
                    new RendererException("Failed inside getLCPixels", exc));
            } else {
                throw exc;
            }
        }
        return pixels2;
    }

    /**
     * The main interface to clsChannelUtility calls DrawChannel2 after stuffing
     * the points into an array of 2-tuples x,y
     *
     * @param pixels the client points
     * @param linetype the line type
     * @param tg the tactical graphic
     * @param shapes
     * @param channelPoints
     */
    public static DrawChannel(pixels: Array<POINT2>,
        linetype: int,
        tg: TGLight,
        shapes: Array<Shape2>,
        channelPoints: Array<POINT2> | null,
        clipBounds: Rectangle2D,
        converter: IPointConversion): void {
        try {
            pixels = clsChannelUtility.getLCPixels(tg, pixels);
            //we must do this because the rotary arrow tip now has to match the
            //anchor point, i.e. the rotary feature can no longer stick out past the anchor point
            //45 pixels shift here matches the 45 pixels shift for catkbyfire found in Channels.GetAXADDouble
            lineutility.adjustCATKBYFIREControlPoint(linetype, pixels, 45);
            if (tg.get_LineType() === TacticalLines.LC && tg.isHostile()) {

                linetype = TacticalLines.LC_HOSTILE;
            }


            let j: int = 0;
            let pixels2: number[] = new Array<number>(pixels.length * 2);
            let n: int = pixels.length;
            //for (j = 0; j < pixels.length; j++) 
            for (j = 0; j < n; j++) {
                pixels2[2 * j] = pixels[j].x;
                pixels2[2 * j + 1] = pixels[j].y;
            }
            clsChannelUtility.DrawChannel2(pixels2, linetype, tg, shapes, channelPoints, clipBounds, converter);
        } catch (exc) {
            if (exc instanceof Error) {
                //clsUtility.WriteFile("error in clsChanneUtility.DrawSegments");
                ErrorLogger.LogException(clsChannelUtility._className, "DrawChannel",
                    new RendererException("Failed inside DrawChannel", exc));
            } else {
                throw exc;
            }
        }
    }

    /**
     * utility for clsMETOC to handle double-backed segments
     *
     * @param tg the tactical graphic object
     */
    public static GetPartitions2(tg: TGLight): Array<P1> | null {
        let partitions: Array<P1>;
        try {
            let pixels: number[] = new Array<number>(tg.Pixels.length * 2);
            let n: int = tg.Pixels.length;
            //for(int j=0;j<tg.Pixels.length;j++)
            for (let j: int = 0; j < n; j++) {
                pixels[2 * j] = tg.Pixels[j].x;
                pixels[2 * j + 1] = tg.Pixels[j].y;
            }

            let segments: boolean[] = new Array<boolean>(pixels.length / 2 - 1);
            if (segments.length === 0) {
                return null;
            }

            let factor: double = arraysupport.getScaledSize(3, tg.get_LineThickness());

            clsUtility.GetSegments(pixels, segments, factor);
            partitions = new Array<P1>();
            clsChannelUtility.GetPartitions(segments, partitions);
        } catch (exc) {
            if (exc instanceof Error) {
                ErrorLogger.LogException(clsChannelUtility._className, "GetPartitions2",
                    new RendererException("Failed inside GetPartitions2", exc));
            } else {
                throw exc;
            }
        }
        return partitions;
    }

    /**
     * The main function for processing channel types. Gets segments, then gets
     * partitions from the segments and then draws the partitions.
     *
     * @param pixels the client points as an array of 2-tuples x,y
     * @param linetype the line type
     * @param tg the tactical graphic object
     * @param shapes
     * @param channelPoints
     */
    private static DrawChannel2(pixels: number[],
        linetype: int,
        tg: TGLight,
        shapes: Array<Shape2>,
        channelPoints: Array<POINT2> | null,
        clipBounds: Rectangle2D,
        converter: IPointConversion): void {
        try {
            let distanceToChannelPoint: ref<number[]> = new ref();
            let j: int = 0;
            let pixels2: number[];
            let channelWidth: int = 0;
            let partitions: Array<P1>;
            let n: int = pixels.length;
            let numPoints: int = 0;
            //LC and others do not call clsUtility.ChannelWidth, but the
            //value array still needs to be allocated or there is a
            //null pointer exception in DrawGoodChannel2
            distanceToChannelPoint.value = new Array<number>(1);
            distanceToChannelPoint.value[0] = arraysupport.getScaledSize(20, tg.get_LineThickness());

            switch (linetype) {
                case TacticalLines.MAIN:
                case TacticalLines.CATK:
                case TacticalLines.CATKBYFIRE:
                case TacticalLines.AIRAOA:
                case TacticalLines.AAAAA:
                case TacticalLines.SPT: {
                    clsUtility.ReorderPixels(pixels);
                    numPoints = pixels.length / 2;

                    if (numPoints < 3) {
                        return;
                    }
                    //moved this to be prior to stuffing pixels2
                    channelWidth = clsUtility.ChannelWidth(pixels, distanceToChannelPoint) / 2;
                    //ValidateChannelPixels2(ref pixels, ref channelWidth, ref distanceToChannelPoint);

                    numPoints = pixels.length / 2;
                    pixels2 = new Array<number>(pixels.length - 2);

                    for (j = 0; j < numPoints; j++) {
                        if (j < numPoints - 1) {
                            pixels2[2 * j] = pixels[2 * j];
                            pixels2[2 * j + 1] = pixels[2 * j + 1];
                        }
                    }
                    break;
                }

                case TacticalLines.LC:
                case TacticalLines.LC_HOSTILE: {
                    channelWidth = arraysupport.getScaledSize(40, tg.get_LineThickness()) as int;// was 20;
                    pixels2 = new Array<number>(pixels.length);
                    n = pixels.length;
                    //for (j = 0; j < pixels.length; j++) 
                    for (j = 0; j < n; j++) {
                        pixels2[j] = pixels[j];
                    }
                    break;
                }

                case TacticalLines.UNSP:
                case TacticalLines.DFENCE:
                case TacticalLines.SFENCE:
                case TacticalLines.DOUBLEA:
                case TacticalLines.LWFENCE:
                case TacticalLines.HWFENCE:
                case TacticalLines.SINGLEC:
                case TacticalLines.DOUBLEC:
                case TacticalLines.TRIPLE: {
                    tg.set_lineCap(BasicStroke.CAP_BUTT);
                    channelWidth = arraysupport.getScaledSize(30, tg.get_LineThickness()) as int;
                    if (Channels.getShiftLines()) {
                        channelWidth = arraysupport.getScaledSize(60, tg.get_LineThickness()) as int;
                    }
                    pixels2 = new Array<number>(pixels.length);
                    n = pixels.length;
                    //for (j = 0; j < pixels.length; j++) 
                    for (j = 0; j < n; j++) {
                        pixels2[j] = pixels[j];
                    }
                    break;
                }

                default: {

                    break;
                }

            }

            //we require new partitions because pixels are dirty
            let segments: boolean[] = new Array<boolean>(Math.trunc(pixels2.length / 2) - 1);
            if (segments.length === 0) {
                return;
            }

            // Line of contact looks bad with small channel corners extending out
            if (linetype === TacticalLines.LC || linetype === TacticalLines.LC_HOSTILE) {
                partitions = new Array();
                let singleLinePartitions: Array<P1> = new Array();
                clsUtility.GetLCPartitions(pixels2, arraysupport.getScaledSize(40, tg.get_LineThickness()), partitions, singleLinePartitions);
                clsChannelUtility.DrawSegments(tg, pixels2, partitions, channelWidth, shapes, channelPoints, distanceToChannelPoint.value[0]);

                if (singleLinePartitions.length > 0) {
                    // Render any small angles that only have side (not channel) as FLOT
                    clsChannelUtility.DrawLCSingleLineSegments(tg, pixels2, singleLinePartitions, shapes, clipBounds, converter);
                }
            } else {
                let factor: double = 3;

                clsUtility.GetSegments(pixels2, segments, factor);
                partitions = new Array();
                clsChannelUtility.GetPartitions(segments, partitions);

                clsChannelUtility.DrawSegments(tg, pixels2, partitions, channelWidth, shapes, channelPoints, distanceToChannelPoint.value[0]);
            }
        } catch (exc) {
            if (exc instanceof Error) {
                ErrorLogger.LogException(clsChannelUtility._className, "DrawChannel2",
                    new RendererException("Failed inside DrawChannel2", exc));
            } else {
                throw exc;
            }
        }
    }
}
